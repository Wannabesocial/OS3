# OS3

Δομη αρχειων.

    (1)config: περιεχει τα 2 trace αρχεια
    (2)inc: περιεχει ολες τις βιβλιοθηκες που εφτιαξα και χρησημοποιησα
    (3)src: περιεχει το source κοδικα τον συναρτισεων
    (4)makefile: για να γινει compile 
    (5)page_manager.c και memory_manager.c: οι 2 main. Ο κωδικας των 3 processes

Πως τρεχουμε την εργασια:

    (1)Σε περιπτωσει που θελουμε αλα αρχεια απο αυτα που υπαρχουν.
        (α)Διαγραφουμε τα αρχεια.
        (β)Φορτωνουμε αυτα που επειθιμουμαι στο "config".
        (γ)Τελος επειδη το path ειναι σε σταθερα θα πρεπει να πατε στον "src/config.c" και να αλαξετε manualy μονο τα ονοματα
        πχ για τα αρχεια Α.trace, B.trace. Αρκει να κανουμε "config/gcc.trace" -> "config/Α.trace" και "config/bzip.trace" -> "config/Β.trace"
    
    (2)Σε καθε αλλη περιπτωση ακολουθουμε τα εξεις βηματα
        (α)Εκτελουμε την εντολη "make".Αυτο κανει compile το καθε .c ξεχωριστα και μετα τα συνθετι σε 2 εκτελεσημα
        (β)Εκτελουμε την εντολη "./memory_manager" ακολουθουμενο απο 3 ή 4 ακαιρεους με την εξεις σειρα
            (1)q (αριθμος block size)
            (2)k (οριο προκειμενου οταν κανουμε k+1 να κανουμε flush)
            (3)total memory aka RAM (ποσο χωρο εχουμε σηνολικα στην RAM. Καθε process εχει total/2, "χωριζουμε" στην μεση την RAM)
            (4)Προερετικα, δεινουμε CAP για το ποσα Trace θα διαβασει απο καθε αρχειο. Defoult = All the file

Ποιο τεχνικα μερι τις εργασις.

Comunication:
    (1)Για να κανω την επικινωνια χρησημοποισα ενα shared memory το οποιο εχει fixed size buffer (μπρει να αλαξει απο το αρχειο "ipc.h") για traces. Και αλλες 2 μεταβλιτες. Μια για να ξερω ποτε τελειωσα απο το διαβαζμα των trace και πρεπει να τερματισει το προγραμα και αλλη μια προκειμενου να ξερω ποτε διαβασα ολο το q_block_Size προκειμενου να υλοποιησω τον FWF αλγοριθμω για αντικατασταση σελιδων.
    (2)Χρησημοποιησα 3 Semaphores. 1 για το memory_manager και 1 για καθε page_manager process. Ο τροπος που λειτουργει ειναι πολυ απλος. Ο MM πρωτα περιμενει τον PM1 να γραψει στην μνημη οταν αυτο γινει το ενημερωνει ο PM1 και τοτε ο PM1 περιμενει να του δωσει σημα ξανα ο MM, ενω ο MM παει και διαβαζει το shared memory. Οταν τελειωσει με τον PM1 γεινετε η ιδια διαδικασια για το PM2 και τον MM.

Τι κανει ο page_manager με λιγα λογια:
    (1)Ανοιγει του semaphores που ειναι δικος του αλλα και του memory manager.
    (2)Ανοιγει και κανει atach το shared memory πανω στην μνημη του process.
    (3)Μετραει ποσα rows πρεπει να διαβασει συνολικα απο το αρχειο σε περιπτωση που δεν εχει δωθει cap.
    (4)Σημφονα με το μεγεθος του αρχειου και τον αριθμω του q_block_size υπολογιζει ποσες φορες πρεπει να διαβασει το αρχειο προκειμενου να εχουμε καθε φορα q_block_size trace.
    (5)Υπολογιζει σημφονα με το q_block_size και το shared memory trace size ποσες φορες θα πρεπει για καθε q_block_size να διαβασει το αρχειο.
    (6)Περιμενει σημα οτι ΜΜ ειναι ετειμος. Γραφει στο shared memory και ιδοποιει τον MM οτι μολις εγραψε.
    (7)Οταν τελειωσει με το trace file ιδοποιει με αντιστιχο συνχρονισμο "(5)" και "(6)" οτι τελειωσε και οτι μπορει πλεον να τερματισει και ο PM αλλα και ο MM.
    (8)Τελος κλεινει το αρχειο trace κλινει του semaphores και κανει untach το shared memory απο την μνημη του

Τι κανει ο memory_manager με λιγα λογια:
    (1)Αρχοικοποιο τις σημαντικες μεταβλιτες με βασει αυτα που μου δινει ο χριστης ή τερματιζω το προγραμα αμμα μου εχει δωσει κατι λαθος
    (2)Διαγραφω παλια IPC aka shared memory και semaphores που μπορει να υπυρχαν μεσα στο συστημα
    (3)Φτιαχνω 2 hash table, 1 για καθε process. Το μεγεθος του hash table μπορει να αλαξει ειναι ορισμενο σε σταθερα στο "hash_table.h" με σταθερα "HASH_TABLE_SIZE". Και τα αρχικοποιο
    (4)Φτιαχνω τα IPCs μου χριαζομαι οπως 3 POSIX semaphores και 1 POSIX shared memory.
    (5)Φτιαχνω τα PM1,PM2 περνοντας τους σε ορισματα καποιες σημαντικες μεταβλιτες οπως q_block_size, max_rows, και εναν ακαιρεο που λεει που θα βρουν το ονομα του αρχειου τους αλλα και που θα βρουν το ονομα του named semaphores τους.
    (6)Μεχρεις οτου να εχω διαβασει οσα Traces μου ειπε ο χρηστης με σωστο συνχρονισμο παω και διαβαζω q_block_size για καθε child process PM εναλαξ και εκτελεω FWF.
    (7)Περιμενω να τερματισουν και να "μαζεψω" τα child processes.
    (8)Εκτυπωνω τα στατιστικα και αποδεσμευω οτι μνημη χρησημοποιησα τοσο στο heap με malloc οσο και τα POSIX IPCs

Επιδι δεν ηταν ξεκαθαρω το πως θα πρεπει να λειτουργει ο FWF ακολουθισα την παρακατω λογικη.:
    (1)Αρχικοποιο εναν μετριτι προκειμενου να ξερω αν εφτασα k+1 page faults
    (2)Παω και βλεπω ολο το trace που εχω με μεγεθος q_block_Size. Αμμα δεν εχω αλλα trace να διαβασω (*) τοτε τελιωνει. Αλιος προχοραω παρακατω
    (3)Αυξανω τον μετριτι που μου λεει ποσα traces εχουν εξεταστει. Και υπολογιζω το entry στο hash table που θα πρεπει να μπει το page.
    (4)Στην περιπτωση που υπαρχει ειδι μεσα στο hash table προχοραω στο επομενο trace, σε αλη περιπτωση προχοραω παρακατω
    (5)(Εχω page fault) Αυξανω τον μετριτη που μου λεει ποσα page fault εχω συνολικα καθως και τον μετριτη που μου λεει ποσα page fault εχω για το σιγκεκριμενο q_block trace.
    (6)Σε περιπτωση που εχω k+1 page faults στο σιγκεκριμενο q_block trace τοτε παω και κανω FLUSH (αδιαζω ολο το hash table). Αυξανω τον μετριτι που μου λεει ποσα συνολικα flush εχω. Αρχικο τον μετριτι που κανει flush αν εχω k+1 page faults. Αρχικοποιο την μνημη για το σιγκεκριμενο process. Και ενημερωνω αναλογα το πως μεταβλιθικε η συνολικη μνημη (RAM). Και προχωραω παρακατω.
    (7)Σε περιπτωση που δεν εχω χωρο στην RAM για το page τοτε απλα προχωραω στο επομενο trace.Αλιος προχοραω παρακατω
    (8)Αυξανω την μνημη που καταλαμβανουν τα pages του process. Ομοιος και για το συνολικα χωρο που καταλαμβανουν και οι 2 διεργασιες. Αμμα ειναι παραπανω απο το μεχρει τωρα μεγιστο ανανεωνω το συνολικα μεγιστο.
    (9)Αμα ειναι "R" αυξανω τον μετριτη για "R" αλιως αυξανω τον μετριτη για "W". Τελος βαζω στο hash table το page aka logical address.

    Επωμενος
    (1)οταν θα κανω flush το μονο page που θα βαλω μεσα θα εινα το τελευταιο. Δηλαδη αυτο που προκαλεσε το k+1 page fault.
    (2)οι μετριτες για 'R' και 'W' αυξανονται μονο αν το page θα μπει οντος μεσα στο page table. Επωμενος αν ενα page ειναι ιδι μεσα για R και μετα το ξαναδιαβασω δεν θα αυξησω 2 φορες τον μετριτη για το R.

    (*)Ο αλγοριθμως εκτελειτε καθε φορα που εχω στην κατοχιμου ειτε trace με μεγεθος q_block_Size. Ειτε λιγοτερο, δηλαδη στο τελος μονο στην περιπτωση που εχω πχ MAX = 1000 αλλα το q_block_Size δεν ειναι καποιος διεραιτεις του MAX πχ 99. Οποτε στο τελος αντι για 99 θα εχω στα "χερια μου" 10 traces.

Τα αποτελεσματα στα στατιστικα ειναι με βασει και τα 2 trace αρχεια και οχι για το καθενα ξεχωριστα. Στο τελος εκτιπωνω με την σιγκεκριμενη σειρα τα εξεις
    (1)Total Reads
    (2)Total Writes
    (3)Page Faults
    (4)Number of Flushes
    (5)Max number of FRAMES (χωρο στην RAM) που ειχε καταλαφθει απο pages.

Αποτελεσματα πειραματων πειραζοντας και τις 3 μεταβλητες Q_block_Size, K, Total_frames.
Q_block_Size    K       Total_frames    MAX_ROWS    |   Reads   Writes  Page_Faults Trace   Flush   Max_Frames
500             4       64              NO_CAP      |   370035  55934   425969      2000000 83266   4
2000            16      256             NO_CAP      |   148639  17094   165733      2000000 9421    16
2000            1000    2000            NO_CAP      |   2547    770     88280       2000000 2       1317
10000           64      1024            NO_CAP      |   76362   8431    84793       2000000 1242    64


Αποτελεσματα πειραματων πειραζοντας μονο το K, Q_block_Size = 2000, Total_frames = 1000, MAX_ROWS = NO_CAP. OXI Αρκετη RAM
K   |   Reads   Writes  Page_Faults Trace   Flush   Max_Frames
32  |   103166  11352   114518      2000000 3165    32
64  |   60995   6805    67800       2000000 743     64
128 |   12524   2047    22506       2000000 38      128
256 |   10565   1765    27617       2000000 24      330
512 |   7981    1316    38733       2000000 17      817
1024|   3910    907     110969      2000000 8       817
2048|   325     492     708240      2000000 0       817

Αποτελεσματα πειραματων πειραζοντας μονο το K, Q_block_Size = 2000, Total_frames = 2000, MAX_ROWS = NO_CAP. Λιγο περισοτερη RAM
K   |   Reads   Writes  Page_Faults Trace   Flush   Max_Frames
32  |   103166  11352   114518      2000000 3165    32
64  |   60995   6805    67800       2000000 743     64
128 |   7012    1470    12437       2000000 16      128
256 |   5099    1211    22220       2000000 7       256
512 |   3865    924     25265       2000000 4       1317
1024|   2547    770     88328       2000000 2       1317
2048|   766     551     161946      2000000 0       1317

Αποτελεσματα πειραματων πειραζοντας μονο το K, Q_block_Size = 2000, Total_frames = 4000, MAX_ROWS = NO_CAP. Αρκετη RAM
K   |   Reads   Writes  Page_Faults Trace   Flush   Max_Frames
32  |   103166  11352   114518      2000000 3165    32
64  |   60995   6805    67800       2000000 743     64
128 |   3408    1209    5620        2000000 7       128
256 |   3309    1119    5427        2000000 3       256
512 |   3050    864     10764       2000000 1       2310
1024|   3044    863     12143       2000000 1       2310
2048|   1649    668     39018       2000000 0       2317